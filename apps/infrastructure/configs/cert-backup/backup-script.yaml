apiVersion: v1
kind: ConfigMap
metadata:
  name: cert-backup-script
  namespace: cert-backup
data:
  backup.sh: |
    #!/bin/sh
    set -e

    BACKUP_DIR=/backup
    TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    echo "Starting cert backup at ${TIMESTAMP}"

    # Secrets to skip:
    #   - k3s-serving: auto-generated by K3s on every boot
    #   - sealed-secrets-key-*: pre-seeded via Ansible Vault
    #   - webhook certs from self-signed issuers (non-LE)
    should_skip() {
      local ns=$1
      local name=$2

      # K3s internal serving cert (regenerated on boot)
      [ "$name" = "k3s-serving" ] && return 0

      # Sealed Secrets key (already managed by Ansible Vault)
      case "$name" in sealed-secrets-key*) return 0 ;; esac

      # Self-signed / internal issuer certs (not from letsencrypt-prod)
      local issuer
      issuer=$(kubectl get secret "$name" -n "$ns" -o jsonpath='{.metadata.annotations.cert-manager\.io/issuer-name}' 2>/dev/null)
      if [ -n "$issuer" ] && [ "$issuer" != "letsencrypt-prod" ]; then
        return 0
      fi

      return 1
    }

    backup_secret() {
      local ns=$1
      local name=$2
      local file="${BACKUP_DIR}/${ns}--${name}.yaml"

      if should_skip "$ns" "$name"; then
        echo "  âŠ˜ ${ns}/${name} (skipped)"
        return
      fi

      echo "Backing up ${ns}/${name}..."
      if kubectl get secret "${name}" -n "${ns}" -o yaml \
        | sed '/^\s*\(resourceVersion\|uid\|creationTimestamp\|selfLink\|managedFields\):/d' \
        | sed '/^\s*manager:/d; /^\s*operation:/d; /^\s*time:/d; /^\s*fieldsType:/d; /^\s*fieldsV1:/d' \
        | sed '/^\s*f:/d' \
        > "${file}.tmp"; then
        mv "${file}.tmp" "${file}"
        echo "  âœ“ ${ns}/${name}"
      else
        echo "  âœ— ${ns}/${name} (failed)"
        rm -f "${file}.tmp"
      fi
    }

    # Discover and back up all TLS secrets (cert-manager issued certs)
    echo "Discovering kubernetes.io/tls secrets..."
    kubectl get secrets --all-namespaces --field-selector type=kubernetes.io/tls \
      -o jsonpath='{range .items[*]}{.metadata.namespace} {.metadata.name}{"\n"}{end}' \
    | while read -r ns name; do
      [ -z "$ns" ] && continue
      backup_secret "$ns" "$name"
    done

    # Back up ACME account keys (type Opaque, managed by cert-manager)
    echo "Discovering ACME account keys..."
    kubectl get secrets --all-namespaces \
      -l cert-manager.io/key-usage=account-key \
      -o jsonpath='{range .items[*]}{.metadata.namespace} {.metadata.name}{"\n"}{end}' 2>/dev/null \
    | while read -r ns name; do
      [ -z "$ns" ] && continue
      backup_secret "$ns" "$name"
    done

    # Also grab the well-known ACME key name as fallback (may not have the label)
    for ns in $(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}'); do
      kubectl get secret letsencrypt-prod-account-key -n "$ns" >/dev/null 2>&1 && \
        backup_secret "$ns" letsencrypt-prod-account-key
    done

    # Remove stale backups for secrets that no longer exist
    echo "Cleaning stale backups..."
    for f in ${BACKUP_DIR}/*.yaml; do
      [ -f "$f" ] || continue
      fname=$(basename "$f" .yaml)
      ns="${fname%%--*}"
      name="${fname#*--}"
      if ! kubectl get secret "$name" -n "$ns" >/dev/null 2>&1 || should_skip "$ns" "$name"; then
        echo "  ðŸ—‘ Removing stale ${fname}.yaml"
        rm -f "$f"
      fi
    done

    echo "Backup complete at $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo "Backed up files:"
    ls -la ${BACKUP_DIR}/
