---
apiVersion: v1
kind: ConfigMap
metadata:
  name: jellyfin-ldap-sync
  namespace: media
data:
  config.json: |
    {
      "ldap": {
        "server": "ak-outpost-ldap-outpost.authentik.svc.cluster.local",
        "port": 389,
        "bind_dn": "cn=ldapservice,ou=users,dc=ldap,dc=benplus,dc=app",
        "base_dn": "ou=users,dc=ldap,dc=benplus,dc=app",
        "user_filter": "(objectClass=user)",
        "group_base_dn": "ou=groups,dc=ldap,dc=benplus,dc=app"
      },
      "jellyfin": {
        "url": "http://jellyfin-main.media.svc.cluster.local:8096"
      },
      "group_library_map": {
        "jellyfin-admins": ["*"],
        "jellyfin-users": ["Movies", "TV Shows", "Anime Movies", "Anime Shows"],
        "jellyfin-users-ru": ["Фильмы", "Сериалы"]
      }
    }

  sync.py: |
    #!/usr/bin/env python3
    """Sync Authentik LDAP group membership to Jellyfin library access."""

    import json
    import os
    import sys
    import urllib.request
    import urllib.error

    import ldap3

    CONFIG_PATH = "/config/config.json"


    def load_config():
        with open(CONFIG_PATH) as f:
            return json.load(f)


    def ldap_get_users(cfg, bind_password):
        """Fetch all LDAP users and their group memberships."""
        server = ldap3.Server(
            cfg["server"], port=cfg["port"], get_info=ldap3.NONE
        )
        conn = ldap3.Connection(
            server, user=cfg["bind_dn"], password=bind_password, auto_bind=True
        )

        conn.search(
            search_base=cfg["base_dn"],
            search_filter=cfg["user_filter"],
            attributes=["cn", "mail", "memberOf"],
        )

        users = {}
        for entry in conn.entries:
            cn = str(entry.cn)
            # Skip service accounts (outpost tokens, ldapservice, etc.)
            if cn.startswith("ak-outpost-") or cn == "ldapservice":
                continue
            groups = []
            if hasattr(entry, "memberOf") and entry.memberOf:
                for group_dn in entry.memberOf:
                    # Extract CN from DN: cn=jellyfin-users,ou=groups,...
                    parts = str(group_dn).split(",")
                    for part in parts:
                        if part.strip().lower().startswith("cn="):
                            groups.append(part.strip()[3:])
                            break
            users[cn] = {"groups": groups, "mail": str(entry.mail) if entry.mail else ""}
        return users


    def jellyfin_api(base_url, api_key, path, method="GET", data=None):
        """Make a Jellyfin API request."""
        url = f"{base_url}{path}"
        headers = {"X-Emby-Token": api_key, "Content-Type": "application/json"}
        body = json.dumps(data).encode() if data else None
        req = urllib.request.Request(url, data=body, headers=headers, method=method)
        try:
            with urllib.request.urlopen(req) as resp:
                if resp.status == 204:
                    return None
                return json.loads(resp.read().decode())
        except urllib.error.HTTPError as e:
            print(f"  API error {e.code} for {method} {path}: {e.read().decode()}")
            raise


    def get_jellyfin_libraries(base_url, api_key):
        """Get all Jellyfin libraries with their IDs."""
        data = jellyfin_api(base_url, api_key, "/Library/VirtualFolders")
        return {lib["Name"]: lib["ItemId"] for lib in data}


    def get_jellyfin_users(base_url, api_key):
        """Get all Jellyfin users."""
        return jellyfin_api(base_url, api_key, "/Users")


    def update_user_policy(base_url, api_key, user_id, user_name, library_ids, is_admin):
        """Update a Jellyfin user's library access and admin status."""
        # Get current policy
        user = jellyfin_api(base_url, api_key, f"/Users/{user_id}")
        policy = user.get("Policy", {})

        # Determine desired state
        if library_ids is None:
            # Wildcard — access to all
            desired_folders = []
            desired_all = True
        else:
            desired_folders = sorted(library_ids)
            desired_all = False

        current_folders = sorted(policy.get("EnabledFolders", []))
        current_all = policy.get("EnableAllFolders", False)
        current_admin = policy.get("IsAdministrator", False)

        # Check if update needed
        if (current_folders == desired_folders
                and current_all == desired_all
                and current_admin == is_admin):
            print(f"  {user_name}: no changes needed")
            return False

        # Update policy
        policy["EnableAllFolders"] = desired_all
        policy["EnabledFolders"] = desired_folders
        policy["IsAdministrator"] = is_admin

        jellyfin_api(
            base_url, api_key,
            f"/Users/{user_id}/Policy",
            method="POST", data=policy,
        )
        action = "all libraries" if desired_all else f"{len(desired_folders)} libraries"
        admin_str = " (admin)" if is_admin else ""
        print(f"  {user_name}: updated → {action}{admin_str}")
        return True


    def main():
        config = load_config()
        ldap_cfg = config["ldap"]
        jf_cfg = config["jellyfin"]
        group_map = config["group_library_map"]

        bind_password = os.environ.get("LDAP_BIND_PASSWORD")
        api_key = os.environ.get("JELLYFIN_API_KEY")

        if not bind_password or not api_key:
            print("ERROR: LDAP_BIND_PASSWORD and JELLYFIN_API_KEY must be set")
            sys.exit(1)

        # 1. Fetch LDAP users
        print("Fetching LDAP users...")
        ldap_users = ldap_get_users(ldap_cfg, bind_password)
        print(f"  Found {len(ldap_users)} users")

        # 2. Fetch Jellyfin libraries
        print("Fetching Jellyfin libraries...")
        jf_libraries = get_jellyfin_libraries(jf_cfg["url"], api_key)
        print(f"  Found {len(jf_libraries)} libraries: {list(jf_libraries.keys())}")

        # 3. Fetch Jellyfin users
        print("Fetching Jellyfin users...")
        jf_users = get_jellyfin_users(jf_cfg["url"], api_key)
        print(f"  Found {len(jf_users)} users")

        # 4. Sync each Jellyfin user that exists in LDAP
        print("Syncing library access...")
        updated = 0
        for jf_user in jf_users:
            jf_name = jf_user["Name"]

            if jf_name not in ldap_users:
                print(f"  {jf_name}: not in LDAP, skipping")
                continue

            ldap_info = ldap_users[jf_name]
            user_groups = ldap_info["groups"]

            # Calculate library union from all groups
            is_admin = "jellyfin-admins" in user_groups
            all_access = False
            library_names = set()

            for group in user_groups:
                if group in group_map:
                    libs = group_map[group]
                    if libs == ["*"]:
                        all_access = True
                    else:
                        library_names.update(libs)

            if all_access:
                library_ids = None  # Signals "all libraries"
            elif library_names:
                # Resolve library names to IDs
                library_ids = []
                for name in library_names:
                    if name in jf_libraries:
                        library_ids.append(jf_libraries[name])
                    else:
                        print(f"  WARNING: Library '{name}' not found in Jellyfin")
            else:
                # User has no mapped groups — no library access
                print(f"  {jf_name}: no mapped groups ({user_groups}), skipping")
                continue

            if update_user_policy(
                jf_cfg["url"], api_key,
                jf_user["Id"], jf_name,
                library_ids, is_admin,
            ):
                updated += 1

        print(f"Done. Updated {updated} user(s).")


    if __name__ == "__main__":
        main()

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: jellyfin-ldap-library-sync
  namespace: media
spec:
  schedule: "*/2 * * * *"
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      backoffLimit: 1
      activeDeadlineSeconds: 120
      template:
        spec:
          restartPolicy: Never
          containers:
            - name: sync
              image: python:alpine
              command:
                - sh
                - -c
                - pip install --quiet ldap3 && python /config/sync.py
              env:
                - name: LDAP_BIND_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: jellyfin-ldap-sync-secret
                      key: ldap-bind-password
                - name: JELLYFIN_API_KEY
                  valueFrom:
                    secretKeyRef:
                      name: jellyfin-ldap-sync-secret
                      key: jellyfin-api-key
              volumeMounts:
                - name: config
                  mountPath: /config
              resources:
                requests:
                  cpu: 50m
                  memory: 64Mi
                limits:
                  cpu: 200m
                  memory: 128Mi
          volumes:
            - name: config
              configMap:
                name: jellyfin-ldap-sync
